<!DOCTYPE html>
<html lang="zh-CN">

<head>

  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js" onerror="handleCdnError('Socket.IO')"></script>
  <meta charset="UTF-8">
  <title>跑步助手</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- 注意: Tailwind CDN 仅用于开发/演示。生产环境建议安装为 PostCSS 插件 -->
  <script src="https://cdn.tailwindcss.com" onerror="handleCdnError()"></script>

  <!-- Google Fonts 标准引入（替代手写 @font-face） -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Zilla+Slab:wght@600;700&family=Noto+Sans+SC:wght@400;600;700&display=swap"
    rel="stylesheet" onerror="handleCdnError()">

  <script src="https://webapi.amap.com/loader.js" onerror="handleCdnError()"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
  <script>
    // 配置TailwindCSS
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { 'sans': ['Noto Sans SC', 'system-ui', 'sans-serif'], 'display': ['Zilla Slab', 'serif'] },
          colors: { 'base': '#7dd3fc' }
        }
      }
    }
  </script>
  <link rel="stylesheet" href="/css/Cascading_Style_Sheets.css">

  <script>
    /**
     * 通用 HTML 片段动态加载函数
     * 
     * 功能说明：
     * 此函数用于从服务器动态加载 HTML 片段，并将其插入到对应的占位符位置。
     * 它统一了所有片段的加载逻辑，避免代码重复，提升可维护性。
     * 
     * 工作流程：
     * 1. 根据片段名称查找对应的占位符元素（ID 格式：{fragmentName}-placeholder）
     * 2. 显示加载提示（如果存在 loading-indicator）
     * 3. 通过 fetch API 从 /html/{fragmentName}.html 获取 HTML 内容
     * 4. 成功后替换占位符的 outerHTML（整个元素被替换）
     * 5. 失败时在加载提示区域显示错误信息
     * 
     * @param {string} fragmentName - 片段名称（与 data-fragment 属性值对应）
     *                                 例如: 'cdn-error-overlay', 'loading-overlay'
     * 
     * @returns {void} 无返回值
     * 
     * @example
     * // 加载 cdn-error-overlay 片段
     * loadFragment('cdn-error-overlay');
     * 
     * @example
     * // 加载 main-app 片段
     * loadFragment('main-app');
     */
    function loadFragment(fragmentName) {
      // 步骤1: 根据片段名称构建占位符的 ID，并获取对应的 DOM 元素
      // 占位符 ID 格式：{fragmentName}-placeholder
      const placeholder = document.getElementById(fragmentName + '-placeholder');
      
      // 防御性检查：如果占位符不存在，则记录错误并终止函数执行
      // 这可以防止后续代码因为 placeholder 为 null 而报错
      if (!placeholder) {
        console.error(`[HTML加载] 未找到占位符: ${fragmentName}-placeholder`);
        return; // 提前退出函数
      }
      
      // 步骤2: 查找占位符内部的加载提示元素
      // 加载提示用于向用户显示"正在加载中..."的状态
      const loadingIndicator = placeholder.querySelector('.loading-indicator');
      
      // 如果加载提示元素存在，则将其显示出来
      // 初始状态下 loading-indicator 的 display 样式被设置为 'none'（隐藏）
      if (loadingIndicator) loadingIndicator.style.display = 'block';
      
      // 步骤3: 使用 fetch API 从服务器动态获取 HTML 片段
      // URL 格式：/html/{fragmentName}.html
      // 例如：/html/cdn-error-overlay.html
      fetch(`/html/${fragmentName}.html`)
        .then(response => {
          // 检查 HTTP 响应状态是否成功（状态码 200-299）
          // 如果响应失败（例如 404 Not Found、500 Server Error），则抛出错误
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          
          // 将响应体解析为纯文本（HTML 字符串）
          return response.text();
        })
        .then(html => {
          // 步骤4: 将获取到的 HTML 内容替换占位符元素
          // outerHTML 会替换整个占位符元素（包括 <div id="xxx-placeholder">...</div> 本身）
          placeholder.outerHTML = html;
          
          // 在控制台记录成功日志，便于调试
          console.log(`[HTML加载] 成功加载片段: ${fragmentName}`);
        })
        .catch(error => {
          // 步骤5: 捕获并处理所有可能的错误（网络错误、解析错误等）
          console.error(`[HTML加载] 加载片段失败: ${fragmentName}`, error);
          
          // 如果加载提示元素存在，则在其中显示友好的错误信息
          // 这样用户就能知道发生了什么，并可以选择刷新页面重试
          if (loadingIndicator) {
            loadingIndicator.innerHTML = '<p style="color: red;">加载失败，请刷新页面重试</p>';
          }
        });
    }
  </script>

  <!-- <script>
    // 通用片段加载器
    function loadFragment(name) {
      const el = document.getElementById(name + '-placeholder');
      if (!el) return;
      fetch('/html/' + name + '.html')
        .then(r => r.text())
        .then(html => { el.outerHTML = html; console.log('[片段✓] ' + name); })
        .catch(e => console.error('[片段✗] ' + name, e));
    }
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('[data-fragment]').forEach(el => {
        const name = el.getAttribute('data-fragment');
        if (name && el.id.endsWith('-placeholder')) loadFragment(name);
      });
    });
  </script> -->
</head>

<body class="text-slate-800 font-sans h-screen overflow-hidden antialiased">

  <!-- CDN 错误提示界面（动态加载） -->
  <div id="cdn-error-overlay-placeholder" data-fragment="cdn-error-overlay">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 cdn-error-overlay...</p>
    </div>
  </div>
  <script>loadFragment('cdn-error-overlay');</script>

  <!-- 新用户添加模态框 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/newUserModal.html API 动态加载 -->


  <!-- 加载遮罩层（动态加载） -->
  <div id="loading-overlay-placeholder" data-fragment="loading-overlay">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 loading-overlay...</p>
    </div>
  </div>
  <script>loadFragment('loading-overlay');</script>

  <!-- 用户认证登录界面 -->
    <!-- ========================================
     动态加载区域: auth-login-container
     原始大小: 4.8 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="auth-login-container-placeholder" data-fragment="auth-login-container">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 auth-login-container...</p>
    </div>
  </div>
  <script>loadFragment('auth-login-container');</script>

  <!-- 登录界面 -->
    <!-- ========================================
     动态加载区域: login-container
     原始大小: 4.4 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="login-container-placeholder" data-fragment="login-container">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 login-container...</p>
    </div>
  </div>
  <script>loadFragment('login-container');</script>

  <!-- 主应用界面 -->
    <!-- ========================================
     动态加载区域: main-app
     原始大小: 10.0 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="main-app-placeholder" data-fragment="main-app">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 main-app...</p>
    </div>
  </div>
  <script>loadFragment('main-app');</script>

    <!-- ========================================
     动态加载区域: multi-account-app
     原始大小: 6.1 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="multi-account-app-placeholder" data-fragment="multi-account-app">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 multi-account-app...</p>
    </div>
  </div>
  <script>loadFragment('multi-account-app');</script>

  <!-- 模态对话框 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/amap-key-modal.html API 动态加载 -->







  <!-- 模态对话框已移至 html_fragments.html，通过 /html/auto-gen-modal.html API 动态加载 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/user-details-modal.html API 动态加载 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/task-details-modal.html API 动态加载 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/account-params-modal.html API 动态加载 -->

  <!-- 模态对话框已移至 html_fragments.html，通过 /html/notifications-modal.html API 动态加载 -->


  <!-- 模态对话框已移至 html_fragments.html，通过 /html/alert-modal.html API 动态加载 -->

    <!-- ========================================
     动态加载区域: admin-panel-modal
     原始大小: 13.5 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="admin-panel-modal-placeholder" data-fragment="admin-panel-modal">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 admin-panel-modal...</p>
    </div>
  </div>
  <script>loadFragment('admin-panel-modal');</script>

  <!-- 模态对话框已移至 html_fragments.html，通过 /html/confirm-modal.html API 动态加载 -->

  <!-- 会话选择模态框 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/session-picker-modal.html API 动态加载 -->

  <!-- 创建权限组模态框 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/create-group-modal.html API 动态加载 -->

  <!-- 编辑权限组权限模态框 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/edit-group-permissions-modal.html API 动态加载 -->

  <!-- 管理用户权限模态框 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/manage-user-permissions-modal.html API 动态加载 -->

  <!-- 设置会话限制模态框 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/set-max-sessions-modal.html API 动态加载 -->

  <!-- 重置用户密码模态框 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/reset-user-password-modal.html API 动态加载 -->

  <!-- 头像裁剪模态框 -->
  <!-- 模态对话框已移至 html_fragments.html，通过 /html/avatar-crop-modal.html API 动态加载 -->

  <script>
    // ==============================================================================
    // 动态加载 JavaScript 代码（全局变量优先）
    // ==============================================================================
    // 加载顺序：
    //   1. JavaScript_globals.js  - 全局变量声明（优先）
    //   2. JavaScript.js          - 主要功能代码
    //
    // 为什么需要这个顺序：
    //   由于使用动态加载，如果全局变量和函数代码一起加载，
    //   可能导致某些函数在执行时全局变量尚未初始化。
    //   将全局变量独立出来并优先加载可以避免此问题。
    // ==============================================================================

    (function() {
      // 第一步：加载全局变量
      const globalsScript = document.createElement('script');
      globalsScript.src = '/JavaScript_globals.js';
      globalsScript.charset = 'utf-8';
      
      globalsScript.onload = function() {
        console.log('[JavaScript加载] 全局变量加载完成 ✓');
        
        // 第二步：加载主要功能代码
        const mainScript = document.createElement('script');
        mainScript.src = '/JavaScript.js';
        mainScript.charset = 'utf-8';
        mainScript.async = false;  // 保持执行顺序
        
        mainScript.onload = function() {
          console.log('[JavaScript加载] 主代码加载完成 ✓');
          // 标记应用初始化完成
          if (typeof appInitialized !== 'undefined') {
            appInitialized = true;
          }
          
          // [BUG修复] 在这里调用 initializeApp()，
          // 确保在 JavaScript.js (主代码) 加载完成后再执行
          if (typeof initializeApp === 'function') {
            initializeApp().catch(err => {
              logMessage_Error('应用初始化失败:', err);
              // 立即显示CDN错误（如果有）
              appInitialized = false;
              if (cdnErrorCount > 0) {
                if (cdnErrorTimer) clearTimeout(cdnErrorTimer);
                const errorOverlay = document.getElementById('cdn-error-overlay');
                if (errorOverlay) {
                  errorOverlay.style.setProperty('display', 'flex', 'important');
                }
              }
            });
          } else {
            console.error('[JavaScript加载] 致命错误: initializeApp 函数未定义');
            alert('应用初始化失败：核心函数丢失，请刷新页面重试');
          }
        };
        
        mainScript.onerror = function() {
          console.error('[JavaScript加载] 主代码加载失败');
          alert('JavaScript 主代码加载失败，请刷新页面重试');
        };
        
        document.head.appendChild(mainScript);
      };
      
      globalsScript.onerror = function() {
        console.error('[JavaScript加载] 全局变量加载失败');
        alert('JavaScript 全局变量加载失败，请刷新页面重试');
      };
      
      document.head.appendChild(globalsScript);
    })();
  </script>
</body>

</html>
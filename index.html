<!DOCTYPE html>
<html lang="zh-CN">

<head>

  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js" onerror="handleCdnError('Socket.IO')"></script>
  <meta charset="UTF-8">
  <title>跑步助手</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- 注意: Tailwind CDN 仅用于开发/演示。生产环境建议安装为 PostCSS 插件 -->
  <script src="https://cdn.tailwindcss.com" onerror="handleCdnError()"></script>

  <!-- Google Fonts 标准引入（替代手写 @font-face） -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Zilla+Slab:wght@600;700&family=Noto+Sans+SC:wght@400;600;700&display=swap"
    rel="stylesheet" onerror="handleCdnError()">

  <script src="https://webapi.amap.com/loader.js" onerror="handleCdnError()"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
  <script>
    // 配置TailwindCSS
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { 'sans': ['Noto Sans SC', 'system-ui', 'sans-serif'], 'display': ['Zilla Slab', 'serif'] },
          colors: { 'base': '#7dd3fc' }
        }
      }
    }
  </script>
  <link rel="stylesheet" href="/css/Cascading_Style_Sheets.css">

  <script>
    /**
     * 通用 HTML 片段动态加载函数
     * 
     * 功能说明：
     * 此函数用于从服务器动态加载 HTML 片段，并将其插入到对应的占位符位置。
     * 它统一了所有片段的加载逻辑，避免代码重复，提升可维护性。
     * 
     * 工作流程：
     * 1. 根据片段名称查找对应的占位符元素（ID 格式：{fragmentName}-placeholder）
     * 2. 显示加载提示（如果存在 loading-indicator）
     * 3. 通过 fetch API 从 /html/{fragmentName}.html 获取 HTML 内容
     * 4. 成功后替换占位符的 outerHTML（整个元素被替换）
     * 5. 失败时在加载提示区域显示错误信息
     * 
     * @param {string} fragmentName - 片段名称（与 data-fragment 属性值对应）
     *                                 例如: 'cdn-error-overlay', 'loading-overlay'
     * 
     * @returns {void} 无返回值
     * 
     * @example
     * // 加载 cdn-error-overlay 片段
     * loadFragment('cdn-error-overlay');
     * 
     * @example
     * // 加载 main-app 片段
     * loadFragment('main-app');
     */
    function loadFragment(fragmentName) {
      // 步骤1: 根据片段名称构建占位符的 ID，并获取对应的 DOM 元素
      // 占位符 ID 格式：{fragmentName}-placeholder
      const placeholder = document.getElementById(fragmentName + '-placeholder');
      
      // 防御性检查：如果占位符不存在，则记录错误并终止函数执行
      // 这可以防止后续代码因为 placeholder 为 null 而报错
      if (!placeholder) {
        console.error(`[HTML加载] 未找到占位符: ${fragmentName}-placeholder`);
        return; // 提前退出函数
      }
      
      // 步骤2: 查找占位符内部的加载提示元素
      // 加载提示用于向用户显示"正在加载中..."的状态
      const loadingIndicator = placeholder.querySelector('.loading-indicator');
      
      // 如果加载提示元素存在，则将其显示出来
      // 初始状态下 loading-indicator 的 display 样式被设置为 'none'（隐藏）
      if (loadingIndicator) loadingIndicator.style.display = 'block';
      
      // 步骤3: 使用 fetch API 从服务器动态获取 HTML 片段
      // URL 格式：/html/{fragmentName}.html
      // 例如：/html/cdn-error-overlay.html
      fetch(`/html/${fragmentName}.html`)
        .then(response => {
          // 检查 HTTP 响应状态是否成功（状态码 200-299）
          // 如果响应失败（例如 404 Not Found、500 Server Error），则抛出错误
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          
          // 将响应体解析为纯文本（HTML 字符串）
          return response.text();
        })
        .then(html => {
          // 步骤4: 将获取到的 HTML 内容替换占位符元素
          // outerHTML 会替换整个占位符元素（包括 <div id="xxx-placeholder">...</div> 本身）
          placeholder.outerHTML = html;
          
          // 在控制台记录成功日志，便于调试
          console.log(`[HTML加载] 成功加载片段: ${fragmentName}`);
        })
        .catch(error => {
          // 步骤5: 捕获并处理所有可能的错误（网络错误、解析错误等）
          console.error(`[HTML加载] 加载片段失败: ${fragmentName}`, error);
          
          // 如果加载提示元素存在，则在其中显示友好的错误信息
          // 这样用户就能知道发生了什么，并可以选择刷新页面重试
          if (loadingIndicator) {
            loadingIndicator.innerHTML = '<p style="color: red;">加载失败，请刷新页面重试</p>';
          }
        });
    }
  </script>

  <!-- <script>
    // 通用片段加载器
    function loadFragment(name) {
      const el = document.getElementById(name + '-placeholder');
      if (!el) return;
      fetch('/html/' + name + '.html')
        .then(r => r.text())
        .then(html => { el.outerHTML = html; console.log('[片段✓] ' + name); })
        .catch(e => console.error('[片段✗] ' + name, e));
    }
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('[data-fragment]').forEach(el => {
        const name = el.getAttribute('data-fragment');
        if (name && el.id.endsWith('-placeholder')) loadFragment(name);
      });
    });
  </script> -->
</head>

<body class="text-slate-800 font-sans h-screen overflow-hidden antialiased">

  <!-- ========================================
   模态对话框统一加载区域
   所有模态框通过 loadFragment 函数从 html_fragments.html 动态加载
   ======================================== -->
  <script>
    // 页面加载完成后立即加载所有模态框
    // 由于模态框在多处被 JavaScript 代码引用，必须确保它们在页面初始化时就存在
    document.addEventListener('DOMContentLoaded', function() {
      // 需要加载的模态框列表（按字母顺序排列）
      const modals = [
        'account-params-modal',
        'alert-modal',
        'amap-key-modal',
        'auto-gen-modal',
        'avatar-crop-modal',
        'confirm-modal',
        'create-group-modal',
        'edit-group-permissions-modal',
        'manage-user-permissions-modal',
        'newUserModal',
        'notifications-modal',
        'reset-user-password-modal',
        'session-picker-modal',
        'set-max-sessions-modal',
        'task-details-modal',
        'user-details-modal'
      ];
      
      // 为每个模态框创建占位符并加载
      modals.forEach(function(modalName) {
        // 创建占位符元素
        const placeholder = document.createElement('div');
        placeholder.id = modalName + '-placeholder';
        placeholder.setAttribute('data-fragment', modalName);
        placeholder.innerHTML = '<div class="loading-indicator" style="display: none; text-align: center; padding: 20px;"><p>正在加载 ' + modalName + '...</p></div>';
        
        // 将占位符添加到 body
        document.body.appendChild(placeholder);
        
        // 立即加载该模态框
        loadFragment(modalName);
      });
      
      console.log('[模态框加载] 开始加载 ' + modals.length + ' 个模态对话框');
    });
  </script>

  <!-- CDN 错误提示界面（动态加载） -->
  <div id="cdn-error-overlay-placeholder" data-fragment="cdn-error-overlay">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 cdn-error-overlay...</p>
    </div>
  </div>
  <script>loadFragment('cdn-error-overlay');</script>

  <!-- 模态对话框通过 DOMContentLoaded 事件统一动态加载，详见上方脚本 -->

  <!-- 加载遮罩层（动态加载） -->
  <div id="loading-overlay-placeholder" data-fragment="loading-overlay">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 loading-overlay...</p>
    </div>
  </div>
  <script>loadFragment('loading-overlay');</script>

  <!-- 用户认证登录界面 -->
    <!-- ========================================
     动态加载区域: auth-login-container
     原始大小: 4.8 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="auth-login-container-placeholder" data-fragment="auth-login-container">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 auth-login-container...</p>
    </div>
  </div>
  <script>loadFragment('auth-login-container');</script>

  <!-- 登录界面 -->
    <!-- ========================================
     动态加载区域: login-container
     原始大小: 4.4 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="login-container-placeholder" data-fragment="login-container">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 login-container...</p>
    </div>
  </div>
  <script>loadFragment('login-container');</script>

  <!-- 主应用界面 -->
    <!-- ========================================
     动态加载区域: main-app
     原始大小: 10.0 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="main-app-placeholder" data-fragment="main-app">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 main-app...</p>
    </div>
  </div>
  <script>loadFragment('main-app');</script>

    <!-- ========================================
     动态加载区域: multi-account-app
     原始大小: 6.1 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="multi-account-app-placeholder" data-fragment="multi-account-app">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 multi-account-app...</p>
    </div>
  </div>
  <script>loadFragment('multi-account-app');</script>

    <!-- ========================================
     动态加载区域: admin-panel-modal
     原始大小: 13.5 KB
     通过 API 动态加载以减小初始页面大小
     ======================================== -->
  <div id="admin-panel-modal-placeholder" data-fragment="admin-panel-modal">
    <!-- 此区域将通过 JavaScript 动态加载 -->
    <div class="loading-indicator" style="display: none; text-align: center; padding: 20px;">
      <p>正在加载 admin-panel-modal...</p>
    </div>
  </div>
  <script>loadFragment('admin-panel-modal');</script>

  <script>
    // ==============================================================================
    // 按需JavaScript加载系统 - 性能优化版本
    // ==============================================================================
    // 优化策略：
    //   1. 保留 JavaScript_globals.js 加载（全局变量必需）
    //   2. 移除 JavaScript.js 完整文件加载，改为按需加载单个函数
    //   3. 其他功能在实际使用时按需动态加载
    //
    // 性能优势：
    //   - 减少初始加载体积（JavaScript.js 约 300KB+ -> 按需加载 < 50KB）
    //   - 提升首次渲染速度
    //   - 利用浏览器缓存，后续交互更快
    // ==============================================================================

    (function() {
      // 函数加载缓存（避免重复加载）
      window.__loadedFunctions = new Set();
      
      // 按需加载JavaScript函数
      window.loadJSFunction = function(functionName) {
        return new Promise((resolve, reject) => {
          // 如果已加载，直接返回
          if (window.__loadedFunctions.has(functionName)) {
            resolve();
            return;
          }
          
          const script = document.createElement('script');
          script.src = `/JavaScript/${functionName}.js`;
          script.charset = 'utf-8';
          script.onload = () => {
            window.__loadedFunctions.add(functionName);
            console.log(`[按需加载] ${functionName} 加载完成 ✓`);
            resolve();
          };
          script.onerror = () => {
            console.error(`[按需加载] ${functionName} 加载失败`);
            reject(new Error(`Failed to load ${functionName}`));
          };
          document.head.appendChild(script);
        });
      };
      
      // 批量按需加载多个函数
      window.loadJSFunctions = function(functionNames) {
        return Promise.all(functionNames.map(name => window.loadJSFunction(name)));
      };
      
      // 第一步：加载全局变量（保留原有逻辑）
      const globalsScript = document.createElement('script');
      globalsScript.src = '/JavaScript/JavaScript_globals.js';
      globalsScript.charset = 'utf-8';
      
      globalsScript.onload = function() {
        console.log('[JavaScript加载] 全局变量加载完成 ✓');
        
        // 第二步：按需加载核心初始化函数（而非完整的 JavaScript.js）
        console.log('[按需加载] 开始加载核心初始化函数...');
        
        // 只加载初始化必需的核心函数
        const coreModules = [
          'handleCdnError',
          'callPythonAPI',
          'initializeApp'
        ];
        
        window.loadJSFunctions(coreModules).then(() => {
          console.log('[按需加载] 核心模块加载完成 ✓');
          window.appInitialized = true;
          
          // 调用应用初始化
          if (typeof initializeApp === 'function') {
            initializeApp().catch(err => {
              console.error('[应用初始化] 失败:', err);
              window.appInitialized = false;
              
              // 显示CDN错误（如果有）
              if (window.cdnErrorCount > 0) {
                if (window.cdnErrorTimer) clearTimeout(window.cdnErrorTimer);
                const errorOverlay = document.getElementById('cdn-error-overlay');
                if (errorOverlay) {
                  errorOverlay.style.setProperty('display', 'flex', 'important');
                }
              }
            });
          } else {
            console.error('[JavaScript加载] 致命错误: initializeApp 函数未定义');
            alert('应用初始化失败：核心函数丢失，请刷新页面重试');
          }
        }).catch(err => {
          console.error('[按需加载] 核心模块加载失败:', err);
          alert('核心功能加载失败，请刷新页面重试');
        });
      };
      
      globalsScript.onerror = function() {
        console.error('[JavaScript加载] 全局变量加载失败');
        alert('JavaScript 全局变量加载失败，请刷新页面重试');
      };
      
      document.head.appendChild(globalsScript);
    })();
  </script>
</body>

</html>